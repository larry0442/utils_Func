## JavaScript 事件循环机制（Event Loop）
主线程不断从消息队列中获取消息，执行消息，这个过程为事件循环，这种机制叫循环机制，取一次消息并执行的过程叫一次循环。
概念
### • 堆（Heap）
堆表示一大块非结构化的内存区域，对象、数据被存放在对中。
### • 栈（Stack）
栈在 JavaScript 中又称执行栈，调用栈，是一种后进先出的数据结构。
JavaScript 有一个主线程（ main thread ）和调用栈（或执行栈 call-stack ），主线各所有的任务都会被放到调用栈等待主线程执行。
### • 队列（Queue）
队列及任务队列（ Task Queue ），是一种先进先出的一种数据结构。在队尾中添加新元素，从队头移除元素。
同步任务和异步任务
• 同步任务是调用立即得到结果，同步任务在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。
• 异步任务是调用无法立即得到结果，需要额外的操作才能预期结果的任务，异步任务不进入主线程，而是进入事件任务队列（Event Queue）的任务，只有事件任务队列（Event Queue）通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
### • 需要理解以下几点：
• JavaScript 分为同步任务和异步任务
• 同步任务都在主线程上执行，形成一个执行栈
• 主线程之外，事件触发线程管理着一个任务队列，只要异步任务（如定时器，http请求）出现，就会在任务队列中放置一个事件
• 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行
#### 宏任务（MacroTask）
每次执行栈执行的任务就是一个宏任务，这其中也包含每次从任务队列中获取一个事件调用并放入执行栈中执行。
主要包含：
script（整体代码）、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate（Node.js环境）
**注意：浏览器在每执行完一个宏任务之后，下一个宏任务开始执行之前，对页面进行重新的渲染。**
#### 微任务（MicroTask）
在当前Task执行结束后立即执行的任务。也就是说，在当前Task任务后，下一个Task之前，在渲染之前微任务会被执行
主要包含：
Promise.then、MutationObserver、process.nextTick（Node.js环境）
**注意：在某一个 MacroTask 执行完后，就会将在它执行期间产生的所有 MicroTask 都执行完毕（在渲染前）。**
### 事件循环运行机制
在事件循环中，每进行一次循环操作称为tick，每一次tick的任务执行过程如下：
• 执行一个宏任务，如果执行栈没有就从任务队列中获取
• 执行过程中产生的微任务，就把它添加到微任务队列中
• 宏任务执行完毕之后（渲染之前），立即依次执行微任务队列中的所有微任务
• 当宏任务执行完毕之后，开始检查渲染，然后GUI线程接管渲染
• 渲染完毕之后，检查是否有 Web Worker 任务，有则执行
• JS线程继续接管，开始下一个宏任务（从事件队列中获取）
#### 流程图：
Promise、async/await、setTimeout在事件循环中的执行
1. • Promise/then、catch中的任务执行
在Promise的代码会被当作同步任务来执行，在主线程的执行中，一旦轮到它执行就会立即执行。而 then 和 catch 中的代码被加入到为微任务队列中，等同步任务全部执行完毕，才会被加入执行栈中执行。
**注意：then 和 catch 中代码被加入到为微任务队列而不是任务队列**
2. • async/await中的任务执行
async中的代码是被当作同步任务来执行，在主线程的执行中，一旦轮到它执行就会立即执行。
await实际上是一个让出线程的标志，await后面的表达式会先执行一遍，将await后面的代码加入到微任务队列中，然后就会跳出整个async函数来执行后面的代码。
3. • setTimeout中的任务执行
JavaScript引擎线程在解析JavaScript代码时，遇到setTimeout，浏览器渲染进程会新开一个线程定时器触发线程，此时，setTimeout中的回调函数将加入任务队列里面，等主线执行栈中上一个宏任务执行完毕，在下一轮事件循环时回调函数才从任务队列中被添加到执行栈中执行。