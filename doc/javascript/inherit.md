## javascript 继承  

  - [1. 原型链继承](#1-%e5%8e%9f%e5%9e%8b%e9%93%be%e7%bb%a7%e6%89%bf)
  - [2. 构造函数继承](#2-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e7%bb%a7%e6%89%bf)
  - [3. 组合继承 （原型链继承+构造函数继承）](#3-%e7%bb%84%e5%90%88%e7%bb%a7%e6%89%bf-%e5%8e%9f%e5%9e%8b%e9%93%be%e7%bb%a7%e6%89%bf%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e7%bb%a7%e6%89%bf)

### 1. 原型链继承
```js
child.prototype = new Parent();
```
- 优点  
  1. 继承父类模板，继承父类的原型对象

- 缺点  
  1. 无法实现多继承因为原型对象已经指定了
  2. 来自原型对象的属性是被共享的，一个实例中修改，所有实例的都会变
  3. child('child1') 这样的传参不起作用 /只有 new Parent('parent1') 这样的才能起作用

### 2. 构造函数继承

在子类构造函数内部使用call或apply来调用父类构造函数
```js
function Parent (name) {
  this.name = name
}
function Child () {
  this.sex = 'boy';
  // 调用父类的构造函数
  // 直接执行了Parent里的代码。使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类。
  Parent.call(this, 'child'); // 治理等同于执行父类代码，this.name = 'child'
  this.name = 'ccc'; // 这里会覆盖上一句。
}
var child1 = new Child();
console.log(child1);
```

- 优点  
    1. 解决子类实例共享父类引用对象的问题
    2. 创建实例时可以传参
    3. 实现多继承
- 缺点  
    1. 构造继承只能继承父类的实例属性和方法，不能继承父类原型的属性和方法(相当于执行父类函数代码，并没有复制原型对象)
    2. 实例并不是父类的实例，只是子类的实例
    3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能

### 3. 组合继承 （原型链继承+构造函数继承）
解决原型链继承和构造函数继承的缺点：
- 使用原型链继承来保证子类能继承到父类原型中的属性和方法
- 使用构造继承来保证子类能继承到父类的实例属性和方法

步骤： 
  1. 通过call/apply在子类构造函数内部调用父类构造函数
  2. 将子类构造函数的原型对象指向父类构造函数创建的一个匿名实例
  3. 修正子类构造函数原型对象的constructor属性，将它指向子类构造函数
   
```js
// 原型链继承
Child.prototype = new Parent()
// 构造函数继承
function Child () {
  Parent.call(this, ...arguments)
}
```

- 优点：  
  1. 可以继承父类实例属性和方法，也能够继承父类原型属性和方法
  2. 弥补了原型链继承中引用属性共享的问题
  3. 可传参，可复用
- 缺点  
  1. 父类构造函数调用两次new Parent() 和 Parent.call()
  2. 生成两个实例，子类实例中的属性和方法会覆盖子类原型(父类实例)上的属性和方法，